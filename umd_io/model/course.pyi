# coding: utf-8

"""
    umd.io

    Welcome to umd.io, the open-source API for University of Maryland data. If you are building a University data-focused app, hack, or project, you’re in the right place. This site will walk you through basic API use and document all supported API calls.  umd.io is a GETful API. It follows RESTful conventions, but for now, you can only get data – you can’t create, update, or destroy.  We're now in version 1! We might add new endpoints or more data to existing responses, but we won't remove anything without a major version change.  If you're looking for the v0 docs, you can find them at https://docs.umd.io/. Please note that v0 is deprecated. It will continue to be supported until at least 2021, but will get no further feature updates, and will eventually be discontinued.  We are actively looking for contributors! Tweet, email, or otherwise get in touch with us.  # noqa: E501

    The version of the OpenAPI document: 1.0.0 Beta
    Contact: hi@umd.io
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from umd_io import schemas  # noqa: F401


class Course(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Represents a course on Testudo
    """


    class MetaOapg:
        
        class properties:
            course_id = schemas.StrSchema
            semester = schemas.NumberSchema
            name = schemas.StrSchema
            dept_id = schemas.StrSchema
            department = schemas.StrSchema
            credits = schemas.StrSchema
            description = schemas.StrSchema
            
            
            class grading_method(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.StrSchema
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'grading_method':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class gen_ed(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ListSchema
                    ):
                    
                    
                        class MetaOapg:
                            items = schemas.StrSchema
                    
                        def __new__(
                            cls,
                            _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                _arg,
                                _configuration=_configuration,
                            )
                    
                        def __getitem__(self, i: int) -> MetaOapg.items:
                            return super().__getitem__(i)
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, list, tuple, ]], typing.List[typing.Union[MetaOapg.items, list, tuple, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'gen_ed':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class core(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.StrSchema
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'core':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            
            
            class relationships(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        
                        
                        class coreqs(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'coreqs':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        
                        
                        class prereqs(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'prereqs':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        
                        
                        class formerly(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'formerly':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        
                        
                        class restrictions(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'restrictions':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        
                        
                        class additional_info(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'additional_info':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        
                        
                        class also_offered_as(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'also_offered_as':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        
                        
                        class credit_granted_for(
                            schemas.StrBase,
                            schemas.NoneBase,
                            schemas.Schema,
                            schemas.NoneStrMixin
                        ):
                        
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[None, str, ],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'credit_granted_for':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    _configuration=_configuration,
                                )
                        __annotations__ = {
                            "coreqs": coreqs,
                            "prereqs": prereqs,
                            "formerly": formerly,
                            "restrictions": restrictions,
                            "additional_info": additional_info,
                            "also_offered_as": also_offered_as,
                            "credit_granted_for": credit_granted_for,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["coreqs"]) -> MetaOapg.properties.coreqs: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["prereqs"]) -> MetaOapg.properties.prereqs: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["formerly"]) -> MetaOapg.properties.formerly: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["restrictions"]) -> MetaOapg.properties.restrictions: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["additional_info"]) -> MetaOapg.properties.additional_info: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["also_offered_as"]) -> MetaOapg.properties.also_offered_as: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["credit_granted_for"]) -> MetaOapg.properties.credit_granted_for: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["coreqs", "prereqs", "formerly", "restrictions", "additional_info", "also_offered_as", "credit_granted_for", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["coreqs"]) -> typing.Union[MetaOapg.properties.coreqs, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["prereqs"]) -> typing.Union[MetaOapg.properties.prereqs, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["formerly"]) -> typing.Union[MetaOapg.properties.formerly, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["restrictions"]) -> typing.Union[MetaOapg.properties.restrictions, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["additional_info"]) -> typing.Union[MetaOapg.properties.additional_info, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["also_offered_as"]) -> typing.Union[MetaOapg.properties.also_offered_as, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["credit_granted_for"]) -> typing.Union[MetaOapg.properties.credit_granted_for, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["coreqs", "prereqs", "formerly", "restrictions", "additional_info", "also_offered_as", "credit_granted_for", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    coreqs: typing.Union[MetaOapg.properties.coreqs, None, str, schemas.Unset] = schemas.unset,
                    prereqs: typing.Union[MetaOapg.properties.prereqs, None, str, schemas.Unset] = schemas.unset,
                    formerly: typing.Union[MetaOapg.properties.formerly, None, str, schemas.Unset] = schemas.unset,
                    restrictions: typing.Union[MetaOapg.properties.restrictions, None, str, schemas.Unset] = schemas.unset,
                    additional_info: typing.Union[MetaOapg.properties.additional_info, None, str, schemas.Unset] = schemas.unset,
                    also_offered_as: typing.Union[MetaOapg.properties.also_offered_as, None, str, schemas.Unset] = schemas.unset,
                    credit_granted_for: typing.Union[MetaOapg.properties.credit_granted_for, None, str, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'relationships':
                    return super().__new__(
                        cls,
                        *_args,
                        coreqs=coreqs,
                        prereqs=prereqs,
                        formerly=formerly,
                        restrictions=restrictions,
                        additional_info=additional_info,
                        also_offered_as=also_offered_as,
                        credit_granted_for=credit_granted_for,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class sections(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            one_of_0 = schemas.StrSchema
                            
                            @classmethod
                            @functools.lru_cache()
                            def one_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.one_of_0,
                                    Section,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *_args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'sections':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            __annotations__ = {
                "course_id": course_id,
                "semester": semester,
                "name": name,
                "dept_id": dept_id,
                "department": department,
                "credits": credits,
                "description": description,
                "grading_method": grading_method,
                "gen_ed": gen_ed,
                "core": core,
                "relationships": relationships,
                "sections": sections,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["course_id"]) -> MetaOapg.properties.course_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["semester"]) -> MetaOapg.properties.semester: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dept_id"]) -> MetaOapg.properties.dept_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["department"]) -> MetaOapg.properties.department: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["credits"]) -> MetaOapg.properties.credits: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["grading_method"]) -> MetaOapg.properties.grading_method: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["gen_ed"]) -> MetaOapg.properties.gen_ed: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["core"]) -> MetaOapg.properties.core: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["relationships"]) -> MetaOapg.properties.relationships: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["sections"]) -> MetaOapg.properties.sections: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["course_id", "semester", "name", "dept_id", "department", "credits", "description", "grading_method", "gen_ed", "core", "relationships", "sections", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["course_id"]) -> typing.Union[MetaOapg.properties.course_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["semester"]) -> typing.Union[MetaOapg.properties.semester, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dept_id"]) -> typing.Union[MetaOapg.properties.dept_id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["department"]) -> typing.Union[MetaOapg.properties.department, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["credits"]) -> typing.Union[MetaOapg.properties.credits, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["grading_method"]) -> typing.Union[MetaOapg.properties.grading_method, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["gen_ed"]) -> typing.Union[MetaOapg.properties.gen_ed, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["core"]) -> typing.Union[MetaOapg.properties.core, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["relationships"]) -> typing.Union[MetaOapg.properties.relationships, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["sections"]) -> typing.Union[MetaOapg.properties.sections, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["course_id", "semester", "name", "dept_id", "department", "credits", "description", "grading_method", "gen_ed", "core", "relationships", "sections", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        course_id: typing.Union[MetaOapg.properties.course_id, str, schemas.Unset] = schemas.unset,
        semester: typing.Union[MetaOapg.properties.semester, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
        dept_id: typing.Union[MetaOapg.properties.dept_id, str, schemas.Unset] = schemas.unset,
        department: typing.Union[MetaOapg.properties.department, str, schemas.Unset] = schemas.unset,
        credits: typing.Union[MetaOapg.properties.credits, str, schemas.Unset] = schemas.unset,
        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
        grading_method: typing.Union[MetaOapg.properties.grading_method, list, tuple, schemas.Unset] = schemas.unset,
        gen_ed: typing.Union[MetaOapg.properties.gen_ed, list, tuple, schemas.Unset] = schemas.unset,
        core: typing.Union[MetaOapg.properties.core, list, tuple, schemas.Unset] = schemas.unset,
        relationships: typing.Union[MetaOapg.properties.relationships, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        sections: typing.Union[MetaOapg.properties.sections, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'Course':
        return super().__new__(
            cls,
            *_args,
            course_id=course_id,
            semester=semester,
            name=name,
            dept_id=dept_id,
            department=department,
            credits=credits,
            description=description,
            grading_method=grading_method,
            gen_ed=gen_ed,
            core=core,
            relationships=relationships,
            sections=sections,
            _configuration=_configuration,
            **kwargs,
        )

from umd_io.model.section import Section
